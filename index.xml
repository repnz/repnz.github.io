<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Low Level Pleasure</title>
    <link>/</link>
    <description>Recent content on Low Level Pleasure</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Nov 2019 01:23:57 +0200</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Abusing Signed Windows Drivers</title>
      <link>/posts/abusing-signed-drivers/</link>
      <pubDate>Wed, 13 Nov 2019 01:23:57 +0200</pubDate>
      
      <guid>/posts/abusing-signed-drivers/</guid>
      <description>The Problem We all know the &amp;ldquo;Driver Signature Enforcement&amp;rdquo; feature in windows. This security feature won&amp;rsquo;t allow you to load unsigned drivers into the windows kernel. To bypass this protection, many attackers use vulnerable signed drivers like turla. They try to find vulnerabilities in these drivers and exploit them. What people don&amp;rsquo;t think about is the fact that it&amp;rsquo;s way simpler than finding an exploitable memory corruption bug in a software driver - sometimes the driver just exposes the functionality via DeviceIoControl and this can be used to perform malicious operations in kernel mode.</description>
    </item>
    
    <item>
      <title>Autochk Rootkit Analysis</title>
      <link>/posts/autochk-rootkit-analysis/</link>
      <pubDate>Fri, 01 Nov 2019 14:00:00 +0300</pubDate>
      
      <guid>/posts/autochk-rootkit-analysis/</guid>
      <description>Introduction Finally had time to write about this rootkit I saw last week. This rootkit is a very simple, it does not employ any uber fancy methods or something, but I do find it nice so I wanted to share. The name of the driver is &amp;ldquo;autochk.sys&amp;rdquo; - that&amp;rsquo;s why we&amp;rsquo;ll call it the autochk rootkit. The sample is already known (28924b6329f5410a5cca30f3530a3fb8a97c23c9509a192f2092cbdf139a91d8), but I haven&amp;rsquo;t found any public analysis. The rootkit was compiled on the 27/8/2017 according to the PE timestamp.</description>
    </item>
    
    <item>
      <title>Reverse Engineering Optimizations: Division By Multiplication</title>
      <link>/posts/reversing-optimizations-division/</link>
      <pubDate>Sat, 26 Oct 2019 18:06:23 +0300</pubDate>
      
      <guid>/posts/reversing-optimizations-division/</guid>
      <description>Intro Reverse engineering compiler optimizations can delay a reverse engineer a-lot. By learning how the compiler optimizes certain things, you can save lots of time. Knowning the pattern, next time you see this optimization you&amp;rsquo;ll recognize right away how to decompile it.
In this blog post series I&amp;rsquo;ll document how to decompile certain compiler optimizations, I hope it&amp;rsquo;ll save some time for you.
Division By Multiplication There&amp;rsquo;s no heavy math in this post lol.</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>/about/</link>
      <pubDate>Sat, 19 Oct 2019 19:37:09 +0300</pubDate>
      
      <guid>/about/</guid>
      <description>Hey!
My name is Ori Damari, and I love low level code.
I hope you find this blog interesting and learn new stuff ..
I do low level research for living. My main interests are:
 Malware Operating Systems Windows Internals Reverse Engineering Kernel Development Software Development  repnz is my nickname (I pronounce it rep notzero..) - I like assembly.
You can contact me easily using twitter messages: @0xrepnz</description>
    </item>
    
    <item>
      <title>Finding main() easily</title>
      <link>/posts/crt-find-main/</link>
      <pubDate>Sat, 12 Oct 2019 01:30:09 +0300</pubDate>
      
      <guid>/posts/crt-find-main/</guid>
      <description>&lt;p&gt;The entry point of an executable is normally the runtime initialization code - so how can you easily find main()?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Random PDC Driver</title>
      <link>/posts/random-pdc-driver/</link>
      <pubDate>Tue, 08 Oct 2019 16:37:09 +0300</pubDate>
      
      <guid>/posts/random-pdc-driver/</guid>
      <description>Found this funny driver: The pdc.sys windows driver has a DriverUnload routine but it calls KeBugCheckEx causing a bluescreen.
Just run &amp;quot;sc stop pdc&amp;quot; and see for yourself ;)
I wonder why they registered DriverUnload if the driver does not support unload.. ðŸ¤” pic.twitter.com/TNpKIZGvZX
&amp;mdash; Ori Damari (@0xrepnz) October 8, 2019  </description>
    </item>
    
    <item>
      <title>Reversing the x64 calling convention</title>
      <link>/posts/x64-calling-convention/</link>
      <pubDate>Sun, 06 Oct 2019 03:24:09 +0300</pubDate>
      
      <guid>/posts/x64-calling-convention/</guid>
      <description>&lt;p&gt;In this article I will explain how the x64 calling convention looks like in Windows and we&amp;rsquo;ll dive
into how it influences reverse engineering.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Windows Critical Threads</title>
      <link>/posts/windows-critical-threads/</link>
      <pubDate>Sat, 21 Sep 2019 17:56:47 +0300</pubDate>
      
      <guid>/posts/windows-critical-threads/</guid>
      <description>&lt;p&gt;In the windows kernel, each kernel object has a Query/SetInformation functions which can be used to
manipulate the kernel objects members from user/kernel mode. These functions receive an &amp;ldquo;INFOCLASS&amp;rdquo;
which is basically the member we want to modify/query.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Windows Imports Searcher</title>
      <link>/posts/windows-imports-searcher/</link>
      <pubDate>Sat, 27 Jul 2019 19:37:09 +0300</pubDate>
      
      <guid>/posts/windows-imports-searcher/</guid>
      <description>&lt;p&gt;Support Windows OS Reversing by searching easily for references to functions across many DLLs&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>